---
layout: post
titile: Greedy Algorithm
date: 2020-04-26 18:10:10
author: leehan
background: '/img/bg-post.jpg'
comments : true
categories : Algorithm
tags : 대학과제
---



# Greedy Algorithm

> 미리 정한 기준에 따라서 매번 가장 좋아보이는 답을 선택하는 알고리즘
>
> (입력)데이터 간의 관계를 고려하지 않고 부분적인 최적해를 찾고, 이들을 모아서 문제의 최적해를 찾는다.
>
> 또한 그리디 알고리즘은 일단 한 번 선택하면 이를 절대로 번복하지 않는다.

그리디 알고리즘은 모든 문제를 해결할 수 없지만 특정 문제를 굉장히 효율적으로 해결할 수 있습니다. *동전 거스름돈 거슬러주기, 크러스컬&프림 알고리즘(최소 신장 트리), 다익스트라 알고리즘(최단 경로 찾기), 부분 배낭 문제, 집합 커버 문제, 스케줄링 문제, 허프만 코딩* 등이 그리디 알고리즘에 속합니다. 보통 지나치게 큰 실행 시간이나 메모리 용량을 줄일 때 유용하죠.

그리디 알고리즘의 특징은 근시안적이라는 겁니다. 때문에 입력 데이터 간의 관계는 전혀 고려하지 않고 수행 과정 내에서 입력 데이터들의 최소값 혹은 최대값을 선택하죠. 이러한 과정의 반복을 통해 문제의 최적해를 구하는 겁니다.

<br/>

<hr>

<br/>

가장 간단한 예로 위에서 언급한 **동전 거스름돈 거슬러주기 문제**를 살펴보도록 하죠.

지금 판매상이 가진 동전 종류가 {500, 100, 50}원 뿐일 때 손님에게 거슬러줘야하는 거스름돈에서 동전의 개수를 최소화할 수 있는 방법을 선택합시다.

입력 값이 뭔지는 알 수 없습니다. 항상 다르겠죠. 심지어 판매상이 가진 거스름돈도 항상 다르게 입력으로 받을 수도 있습니다. 때문에 입력값이 아닌 문제를 해결하는 로직에 집중해야 합니다. 사실 이 간단한 문제가 그리디 알고리즘의 핵심을 표현해 줍니다.

우선 손님에게 줘야하는 거스름돈이 입력으로서 들어오면, 현재 판매상이 가진 동전의 종류 중 *가장 최대값*.. 그러니까 지금은 500원으로 나누어줍니다. 그 나눈 몫이 그 동전이 쓰일 개수로서 표현될 것이고 이 과정을 거치면 이제 최대값인 500원은 더이상 언급될 필요가 없습니다.

그리고 500으로 나눴는데 나머지가 존재한다면 그 나머지를 *다음 최대값*으로 나눠보고 이러한 과정을 동전의 종류가 최소값에 닿거나 나머지가 0이 될 때까지 반복해 줍니다. 이렇게 하면 쉽게 답을 구할 수 있습니다.

이러한 방법을 적용하면 현재 가진 동전의 종류가 무엇이든, 거스름돈 값이 얼마로 들어오든 항상 최소의 동전 개수로 거스름돈을 지불할 수 있을 겁니다.

다만, 이 동전 찾기 문제는 그리디 알고리즘의 한계를 설명하는 가장 간단한 문제이기도 합니다. 왜냐하면 제가 위에서 언급한 문제의 해인 *최소 동전의 개수*가 해로서 도출되려면 **입력으로 들어오는 동전 종류가 A<sub>i</sub>는 A<sub>i-1</sub>의 배수**라는 조건이 붙어야하기 때문입니다.

간단하게 예를 들어보죠.

만약 900원이라는 거스름돈이 들어왔는데 현재 가진 동전의 종류가 {500, 100,  50}입니다. 그렇다면 위에서 설명한 그리디 알고리즘을 적용하여 *500원 1개 100원 4개*라는 답을 도출할 수 있을 것입니다.

그러나! 만약 같은 900원의 입력값에 동전의 종류가 {500, 160, 100, 10} 이라면? 이 경우에도 필요한 최소 동전의 개수는 똑같이 500원 1개 100원 4개일 겁니다. 하지만 그리디 알고리즘을 적용했을 때의 결과는 500원 1개, 160원 2개, 10원 8개나 나올 겁니다.

왜 이런 오류가 생기는 걸까요? 그건 그리디 알고리즘이 근시안적인 선택을 하기 때문입니다. 근시안적인 선택을 하는 그리디 알고리즘의 핵심은 **항상 그 순간에 최적인 선택을 하는 것**입니다. 그러니 900에서 최대 동전값인 500을 뺀 후, 400에서 160을 뺄 때 뒤에 100원으로 4개를 지불하는 게 더 이득인 줄을 모르고 그 순간의 최적해로서 160을 두 번 빼버리는 것이죠.

이런 이유 때문에 그리디 알고리즘은 제한된 상황에서만 사용됩니다. 이러한 최적화 문제의 딜레마를 해결하고 싶다면 동적 계획 알고리즘을 사용하는 게 낫겠죠.

저는 알고리즘을 공부하며 여러 종류의 그리디 알고리즘 문제를 풀어봤습니다. 그 중 **근시안적인 선택**이라는 주제를 가장 잘 나타낸다고 생각하는 문제를 가져왔습니다.

<br/>

#### 1080번 행렬

[백준 온라인](https://www.acmicpc.net/problem/1080)의 그리디 알고리즘 카테고리에 가보면 만날 수 있는 문제입니다. 풀이는 상당히 쉬워요. 내용은 다음과 같습니다.

> 0과 1로만 이루어진 행렬 A와 행렬 B가 있다. 이때, 행렬 A를 행렬 B로 바꾸는데 필요한 연산의 횟수의 최솟값을 구하는 프로그램을 작성하시오.
>
> 행렬을 변환하는 연산은 어떤 3*3크기의 부분 행렬에 있는 모든 원소를 뒤집는 것이다. (0 -> 1, 1 -> 0)

입력

> 첫째 줄에 행렬의 크기 N M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 행렬 A가 주어지고, 그 다음줄부터 N개의 줄에는 행렬 B가 주어진다.

출력

> 첫째 줄에 문제의 정답을 출력한다. 만약 A를 B로 바꿀 수 없다면 -1을 출력한다.

즉, A 행렬을 3*3 단위로 뒤집어가며 B 행렬과 똑같이 만들라는 것입니다. 왜 이 문제가 근시안적인 선택을 잘 나타냈냐고 생각하냐면, 행렬의 처음부터 (0, 0) 부분에서 출발하여 한 칸씩 점진적으로 움직이며 각 칸마다 *뒤집을지 안뒤집을지를 근시안적으로 판단*하기 때문입니다.

예를 들어,

{ 0 0 0

   1 1 1

   1 1 1

   0 0 0 }

이라는 A 행렬과

{ 1 1 1

   0 0 0

   0 0 0

   0 0 0 }

이라는 B 행렬이 있다고 가정합시다.

가장 최초의 판단점은 (0, 0) 위치의 원소가 될 것입니다. 이곳에서 시작하여 한칸씩 이동하여 아래로 움직일 것이기 때문에 만약 이 위치의 원소가 B 행렬과 다르다면 **지금 이 순간에 뒤집는 것 외에는** 방법이 없습니다.

위의 예시는 (0,0) 위치의 A의 원소 0이 B의 1과 다르기 때문에 뒤집어주면 한번만에 두 행렬이 같아집니다.

판단점을 지그재그로 아래로 내려가면, 항상 그 순간이 **현재의 원소를 바꿀 수 있는 유일한 선택지**가 됩니다. 그렇다면 매순간 최적의 선택을 하는 탐욕 알고리즘으로 충분히 풀 수 있다는 뜻입니다.

```
A
0000
0010
0000
B
1001
1011
1001
```

위처럼 A와 B가 주어진다면 그리디 알고리즘은 단순히 A(0, 0)에서부터 시작하여 최적의 판단을 내립니다. <ins>이 부분이 B와 같은가? Yes -> 그냥 지나간다 No -> 3*3을 뒤집는다.</ins> 이런식으로 그리디 알고리즘으로 아주 단순하게 최소의 뒤집는 횟수를 구할 수 있습니다.

```c++
/**
행렬의 원소와 true/false 요소를 비교하여 3*3 범위의 원소를 뒤집기만 하면 되는 아주 간단한 문제다.
행렬의 (0,0)의 값이 1인데 원하는 값이 0이라면 위치 (0,0)에서밖에 값을 뒤집을 수 없다.
즉, (0,0)에서부터 끝까지 차례대로 진행하여 값을 뒤집으면 최소 연산 횟수가 나오게 된다. 
**/

#include <iostream>
#include <string>
#include <vector>

using namespace std;

int n, m, count = 0;
vector<string> A, B;

//3*3을 뒤집는 함수 
void reverse(int x, int y) {
    count++;
    int i, j;
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 3; j++) {
            if(A[x+i][y+j] == '0') A[x+i][y+j] = '1';
            else A[x+i][y+j] = '0';
        }
    }
}

int main()
{
	int i, j;
	string s;
	cin >> n >> m;
	//행렬을 입력받는다. 
	for(i=0; i<n; i++)
	{
		cin >> s;
		A.push_back(s);
	}
	//행렬 B도 입력받는다. 
	for(i=0; i<n; i++)
	{
		cin >> s;
		B.push_back(s);
	}
    //A와 B의 차이가 발견되면 즉각 뒤집는다.
	for (i = 0; i < n-2; i++) {
        for (j = 0; j < m-2; j++) {
            if (A[i][j] != B[i][j]) {
                reverse(i, j);
            }
        }
    }
	//모든 과정을 마쳤음에도 두 행렬이 같지않다면 -1을 리턴한다.
	for (i = 0; i < n; i++) {
        if (flag) {
            for (j = 0; j < m; j++) {
                if (A[i][j] != B[i][j]) {
                    cout << "-1" << endl;
                    return 0;
                }
            }
        }
    }
	
	cout << count << endl;
	return 0;
}
```

물론 이렇게 간단한 문제들만 풀라고 그리디 알고리즘이 있는 건 아닙니다. 그리디 알고리즘은 단순하지만 보다 복잡한 문제도 풀 수 있습니다.

다음 문제를 살펴보죠.

<br/>

#### 멀티탭 스케줄링

문제

> 기숙사에서 살고 있는 준규는 한 개의 멀티탭을 이용하고 있다. 준규는 키보드, 헤어드라이기, 핸드폰 충전기, 디지털 카메라 충전기 등 여러 개의 전기용품을 사용하면서 어쩔 수 없이 각종 전기용품의 플러그를 뺐다 꽂았다 하는 불편함을 겪고 있다. 그래서 준규는 자신의 생활 패턴을 분석하여, 자기가 사용하고 있는 전기용품의 사용순서를 알아내었고, 이를 기반으로 플러그를 빼는 횟수를 최소화하는 방법을 고안하여 보다 쾌적한 생활환경을 만들려고 한다.
>
> 예를 들어 3 구(구멍이 세 개 달린) 멀티탭을 쓸 때, 전기용품의 사용 순서가 아래와 같이 주어진다면, 
>
> 1. 키보드
> 2. 헤어드라이기
> 3. 핸드폰 충전기
> 4. 디지털 카메라 충전기
> 5. 키보드
> 6. 헤어드라이기
>
> 키보드, 헤어드라이기, 핸드폰 충전기의 플러그를 순서대로 멀티탭에 꽂은 다음 디지털 카메라 충전기 플러그를 꽂기 전에 핸드폰충전기 플러그를 빼는 것이 최적일 것이므로 플러그는 한 번만 빼면 된다. 

입력

> 첫 줄에는 멀티탭 구멍의 개수 N (1 ≤ N ≤ 100)과 전기 용품의 총 사용횟수 K (1 ≤ K ≤ 100)가 정수로 주어진다. 두 번째 줄에는 전기용품의 이름이 K 이하의 자연수로 사용 순서대로 주어진다. 각 줄의 모든 정수 사이는 공백문자로 구분되어 있다. 

출력

> 하나씩 플러그를 빼는 최소의 횟수를 출력하시오. 

백준 온라인 1700번인 이 문제는 페이지 교체 기법과 쏙 빼닮은 문제입니다. 페이지 교체 알고리즘이란 페이지 부재가 발생했을 때 가상기억장치의 필요한 페이지를 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용 중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법입니다.

멀티탭은 페이지 프레임과 매핑되고 페이지는 플러그와 매핑됩니다. 그리고 사용할 플러그의 순서를 미리 제시해줬죠. 이때 페이지의 교체 회수, 즉 플러그를 뽑았다 꼽는 회수를 최소화하라는 문제입니다.

최적화를 통해서 풀어나가 봅시다. 우선 사용해야할 플러그의 순서가 {3 1 1 2 5 3 1}이고 멀티탭의 구멍이 3개라고 가정해 봅시다. 일단 반복문을 돌려서 3 1 1 2 5 3 1의 순서대로 플러그를 고려할 수 있겠죠. 이때 각 플러그마다의 최선의 선택을 하도록 하려면 어떤 가정을 세워야할까요?

우선 첫 번째, 멀티탭의 구멍이 남아있고 지금 쓰려는 플러그가 꽂혀있지 않다면, *플러그를 꼽아줍시다.*

두번째, 멀티탭의 구멍이 남아있지만 지금 쓰려는 플러그가 꽂혀있다면, *플러그를 새로 꽂을 필요없이 그냥 지나갑니다.*

세번째, 멀티탭의 구멍에 여유가 없지만 지금 쓰려는 플러그가 꽂혀있다면, *플러그를 새로 꽂을 필요없이 그냥 지나갑니다.*

그러나 네번째, 멀티탭의 구멍에 여유가 없는데 지금 쓰려는 플러그가 꽂혀있지 않다면, **다른 플러그를 뽑고 새 플러그를 꼽아줍니다.**

여기까지는 쉽습니다. 아주 간단한 근시안적 선택이죠. 이러한 방식을 수행하면 무사히 모든 플러그의 순서를 만족시킬 수 있을 겁니다. 그러나 여기서 문제는 새롭게 대두됩니다. <ins>플러그를 뽑고 새로운 걸 꼽아줘야할 때, 과연 어떤 플러그를 뽑을 것인가?</ins> 여기에서 최소로 플러그를 뽑는 회수가 결정됩니다.

어떤 플러그를 뽑아야하는지에 대한 대답은 **OPT(OPTimal replacement, 최적교체)**로 해결할 수 있습니다. OPT는 *앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법*입니다. 즉, 앞으로 가장 오랫동안 사용하지 않을 플러그를 뽑고 새로운 걸 꽂으라는 거겠죠?

그러면 봅시다.

제일 처음 멀티탭의 구멍이 O O O 이렇게 3개가 있습니다.

먼저 사용될 플러그는 3이니까, 

3 O O

이 되겠죠. 그 다음은 1이 쓰이니까

3 1 O

이 됩니다. 그 다음은 또 1이 쓰이는데 1은 이미 꽂혀있으니 새걸 꽂을 필요가 없습니다. 그 다음은 2가 쓰이니 멀티탭에 꽂아줍니다.

3 1 2

그리고 다음은 5가 쓰입니다. 여기에서 멀티탭에 구멍에 여유는 없습니다. 기존의 플러그를 뽑아야합니다. 이때 3이나 1을 뽑는다고 가정합시다. 그러면 5 1 2 & 3 5 2의 상황에서 다음에 쓰일 3이나 1을 다시 쓰기 위해 플러그를 또 뽑고 꼽아줘야하는 번거로움이 발생합니다. 이러면 최소 회수를 구할 수 없습니다.

이때 무엇을 뽑을 것이냐? 의 선택에서 가장 최적의 선택은 앞으로 쓰일 일이 없는 2를 뽑는 거겠죠. 그런데 만약 입력이 {3 1 1 2 5 3 1 1 2  2 2}라면? 이러면 1도 2도 3도 모두 사용됩니다. 이럴때 가장 나중에 사용되는 2를 뽑아주는게 최소 회수를 구하는 방법이라는 겁니다.

이러면 아까 문제보다는 복잡한 그리디 알고리즘이 형성됩니다. {3 1 1 2 5 3 1 1 2 2 2}를 순차적으로 진행하며,

1. 구멍이 남아있고, 플럭그가 새거라면, 꼽는다.
2. 구멍이 남아있지만, 플러그가 이미 있다면, 그냥 지나간다.
3. 구멍이 없지만, 플러그가 이미 있다면, 그냥 지나간다.
4. 구멍이 없고, 플러그가 새거라면, 꽂혀있는 것중 추후에 쓰일 일이 없는 걸 뽑는다.
5. 구멍이 없고, 플러그가 새거이며, 꽂힌 플러그 모두가 추후에 사용된다면, 처음 사용되는 시기가 가장 마지막인 플러그를 뽑는다.

이렇게 됩니다. 이러한 기준에 맞춰 최적의 선택을 이어나가줘야해요. 그러면 최소로 플러그를 뽑는 횟수를 구할 수 있을 겁니다.

```c++
#include <iostream>
using namespace std;

int page[100] = {0,};
int page_seq[100] = {0,};
int page_num[101] = {0,};
int page_test[100] = {0,};
int n, m; 

int wherelast(int now)
{
	int rp;
	int cnt = n;
	
	for(int i=0; i<n; i++)
	{
		page_test[i] = page[i];
	}
    
	for(int i=now; i<m; i++)
	{
		for(int j=0; j<n; j++)
		{
			if(page_seq[i] == page_test[j])
			{
				page_test[j] = 0;
				rp = j;
				break;
			}
		}
	}
	return rp;
}

int main()
{
	int i, j, t;
	cin >> n >> m;
	bool flag = false;
	bool flag2 = false;
	bool flag3 = false;
	
	//page_seq
	for(i=0; i<m; i++)
	{
		cin >> page_seq[i];
	}
	
	//page_num
	for(i=0; i<m+1; i++)
	{
		for(j=0; j<m; j++)
		{
			if(page_seq[j] == i) page_num[i]++;
		}
	}
	
	int length = 0;
	int count = 0;
	for(i=0; i<m; i++)
	{
		//page가 다 안채워진 경우 
		if(page[n-1] == 0)
		{
			//넣으려는 숫자가 이미 page에 있는지 검사 
			for(j=0; j<n; j++)
			{
				if(page_seq[i] == page[j])
				{
					flag = true; 
					page_num[page[j]]--;
					break;
				}
			}
			//넣으려는 숫자가 page 안에 없을 경우 
			if(flag == false)
			{
				page[length++] = page_seq[i];
				page_num[page_seq[i]]--;
			}
			flag = false;	
		}
		//page가 이미 다 찬 경우
		else
		{
			//넣으려는 숫자가 이미 page에 있는지 확인
			for(j=0; j<n; j++)
			{
				if(page_seq[i] == page[j])
				{
					flag2=true;
					page_num[page[j]]--;
					break;
				}
			}
			//넣으려는 숫자가 page 안에 없을 경우
			if(flag2 == false)
			{
				//page 안에 추후에 사용될 계획이 없는 자원을 탐색
				for(j=0; j<n; j++)
				{
					if(page_num[page[j]] == 0)
					{
						flag3 = true;
						page[j] = page_seq[i];
						page_num[page[j]]--;
						count++;
						break;
					}
				}
				//page 안에 요소들이 추후에 모두 사용될 경우
				if(flag3 == false)
				{
					t = wherelast(i);
					page[t] = page_seq[i];
					page_num[page[t]]--;
					count++;
				}
				flag3 = false;
			}
			flag2 = false;
		}
	}
	
	cout << count << endl;	
	return 0;
}
```

<br/>

<br/>

#### 반도체 설계

마지막으로 한 문제가 더 하고 가겠습니다.

문제

> 반도체를 설계할 때 n개의 포트를 다른 n개의 포트와 연결해야 할 때가 있다.
>
> ![img](https://www.acmicpc.net/JudgeOnline/upload/201103/chip.png)
>
> 예를 들어 왼쪽 그림이 n개의 포트와 다른 n개의 포트를 어떻게 연결해야 하는지를 나타낸다. 하지만 이와 같이 연결을 할 경우에는 연결선이 서로 꼬이기 때문에 이와 같이 연결할 수 없다. n개의 포트가 다른 n개의 포트와 어떻게 연결되어야 하는지가 주어졌을 때, 연결선이 서로 꼬이지(겹치지, 교차하지) 않도록 하면서 최대 몇 개까지 연결할 수 있는지를 알아내는 프로그램을 작성하시오

입력

> 첫째 줄에 정수 n(1 ≤ n ≤ 40,000)이 주어진다. 다음 줄에는 차례로 1번 포트와 연결되어야 하는 포트 번호, 2번 포트와 연결되어야 하는 포트 번호, …, n번 포트와 연결되어야 하는 포트 번호가 주어진다. 이 수들은 1 이상 n 이하이며 서로 같은 수는 없다고 가정하자.

출력

> 첫째 줄에 최대 연결 개수를 출력한다.

이건 백준 온라인 2352번에 가면 만나볼 수 있는 그리디 알고리즘 문제입니다. 구하라고하는 건 `겹치지 않는 최대 선의 개수`입니다.

아주 단순하게 생각하면 1부터 6까지 가면서 겹치지 않는 선을 구해 최대 선의 개수가 나오는 조합이 나올때까지 반복하는 걸 생각할 수 있지만 이건 그리디 알고리즘과는 거리가 멉니다.

사실 이런 문제를 풀 때는 LIS를 사용하는 것이 거의 공식화되어있는데 이 LIS(최장 수열)을 구하는 게 그리디 알고리즘으로 분류되는 것이 신기해서 이 문제를 가져와봤습니다.

[LIS(Longest Increasing Subsequence)](https://jason9319.tistory.com/113)에 관한 내용은 JASON9319 님의 블로그를 참고했습니다.

알고리즘의 순서는 다음과 같습니다.

1. 입력이 {4 2 6 3 1 5} 일 때 제일 처음 숫자인 4를 가져옵니다.
2. 그 숫자 4를 다음 순번인 2와 비교합니다.
3. 2는 4보다 작습니다. 즉, 2를 4앞에 붙이면 **증가 수열**이 되지 않습니다. 대신, 2보다 큰 수인 4를 2로 교체해줍니다.
4. 그리고 현재 숫자 2를 그 다음 숫자인 6과 비교해줍니다. 6은 2보다 큽니다. 즉, 6을 2앞에다 붙이면 증가 수열이 됩니다. 그러니 추가해주도록 합니다.
5. 그럼 현재 {2 6}과 3을 비교해줍니다. 3은 6보다 작습니다. 그러나 2보다는 큽니다. 그러니 3보다 작지 않은 숫자인 6과 3을 교환해주도록 합니다.
6. 그 후 {2 3}과 1을 비교해줍니다. 1은 2와 3 모두보다 작습니다. 즉, 1로 교환할 수 있는 숫자가 없습니다.
7. 그 다음 숫자인 5와 비교해줍니다. 5는 2와 3보다 큽니다. 즉, 5를 앞에다 붙이면 증가 수열이 됩니다. 그래서 최종적으로는 {2 3 5}가 최대 길이로 나올 수 있는 증가 수열이 됩니다.

잘 보면 매순간마다 근시안적인 선택을 하는 최적화 문제고, 부분문제의 최적해가 전체 문제의 최적해에 포함되며, 다시 반복하지도 않습니다.

최대 선의 개수의 경우를 모두 고려하는 것보다 훨씬 빠릅니다. 그러나 최적의 해보다는 적합한 해를 찾는 알고리즘의 특성상 '최장수열의 길이'까지는 구할 수 있을지 몰라도 이 그리디 알고리즘으로는 '최장수열의 내용'까지는 구할 수 없다는 단점이 있습니다.

예를 들어 최장 수열의 길이를 만족하는 조합이 3개가 있을 때 그 3개의 경우를 모두 구할 수 없다는 뜻이죠. 구하려면 모든 경우의 수를 고려하는 DP 알고리즘을 사용해야합니다.