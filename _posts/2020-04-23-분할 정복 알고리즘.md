---
layout: post
titile: 분할 정복 알고리즘
date: 2020-04-23 18:00:00
author: leehan
background: '/img/bg-post.jpg'
comments : true
categories : Algorithm
tags : Algorithm
---



# 분할 정복 알고리즘

분할 정복 알고리즘은 주어진 문제의 입력을 분할하여 문제를 해결하는 방식의 알고리즘입니다. 분할된 문제는 부분 문제라고 하는데, 각 부분문제에 대하여 `동일한 알고리즘`을 적용하여 각 부분 문제의 해를 얻고 이 해들을 취합하여 전체 문제의 해를 얻는게 일반적입니다!

문제의 입력을 단순히 분할만 한다고 해를 구할수는 없겠죠? 중요한 건 분할한 문제들을 정복해나가는 것입니다. 이 정복하는 방법은 알고리즘에 따라 다르지만 일반적으로는 *부분문제들의 해를 추합하여 보다 큰 부분문제의 해를 구합니다.*

<br/>

<br/>

## 1. 합병 정렬

분할 정복을 대표하는 알고리즘 중 하나인 합병 정렬<sub>병합 정렬, Maerge Sort</sub>입니다. 

병합 정렬은 부분 문제의 크기가 1/2로 감소합니다. n개의 숫자들을 n/2개씩 2개의 부분문제로 분할하고, 각각의 부분문제를 재귀적으로 합병 정렬한 후, 2개의 정렬된 부분을 합병하여 정렬(정복)합니다. 즉, 합병 과정이 문제를 정복하는 것이죠.

```
MergeSort(A, p, q)
입력 : A[p]~A[q]
출력 : 정렬된 A[p]~A[q]
1. if(p < q) {
2. k = [(p+q)/2]
3. MergeSort(A, p, k)
4. MergeSort(A, k+1, q)
5. A[p]~A[k]와 A[k+1]~A[q]를 합병한다.
}
```

위는 분할 정복에 기반을 둔 합병 정렬 알고리즘의 예시입니다.

A[p]~A[q]라는 다수의 배열이 입력으로 들어왔습니다. 원하는 출력은 이 배열들이 p~q로 정렬된 상태입니다.

먼저 1 Line에서는 정렬할 부분의 원수의 수가 2개 이상일 때에만 다음 단계가 수행되도록 하빈다. p와 q 사이의  고저가 없다면 if문은 실행되지 않겠죠. 예를 들어 p=q라면 그건 원소가 하나라는 뜻이겠죠.

2 Line에서는 정렬할 부분의 원소들을 1/2로 나누기 위해, k=[(p+q)/2]를 계산합니다. 이때 소수점이 나오면 소수점 이하는 버려주도록 합니다.

3~4 Line에서는 MergeSort(A, p, k)와 MergeSort(A, k+1, q)를 재귀 호출하여 각각 정렬합니다.

5 Line에서는 각각 정렬된 부분을 합병합니다. 합병 과정의 마지막에는 임시 배열에 있는 합병된 원소들을 배열 A로 복사합니다. 즉, 임시 배열 B[p]~B[q]를 A[p]~A[q]로 복사합니다.

다른 [합병 정렬의 예제]([https://janghw.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Divide-and-Conquer-%EB%B6%84%ED%95%A0%EC%A0%95%EB%B3%B5](https://janghw.tistory.com/entry/알고리즘-Divide-and-Conquer-분할정복))도 살펴보도록 합시다.

만약 다음과 같은 데이터 집합을 가정하자.

#### {7, 2, 5, 9, 6, 4, 1, 3, 8}

이 데이터 집합을 전체가 오름차순으로 정렬된 상태로 만들고 싶다. 이때 분할 알고리즘을 적용하기 위하여 데이터 모음을 더이상 쪼갤 수 없을 때까지 반으로 쪼갰다.

#### {7, 2, 5, 9, 6}  {4, 1, 3, 8}

#### {7, 2, 5}  {9, 6}  {4, 1}  {3, 8}

.

.

#### {7, 2} {5} {9} {6} {4} {1} {3} {8}

이제 합병 정렬 알고리즘을 적용해봅시다. 각각의 분할된 데이터 모음들을 다시 합병 시켜 정렬 시킨 후에 다시 합병하는 식으로 가겠죠.

#### {2, 5,  7} {6, 9} {1, 4} {3, 8}

#### {2, 5, 6, 7, 9} {1, 3, 4, 8}

#### {1, 2, 3, 4, 5, 6, 7, 8, 9}

이렇게요.

사람의 경우는 이 데이터 모음들을 분할하지 않고 그냥 정렬하는 게 더 빠르고 편하겠죠. 그러나 컴퓨터의 경우는 이렇게 분할해서 정렬하는 게 문제의 복잡도를 좀 더 줄여준다고 합니다.

만약 n개의 문자을 분할 없이 정렬한다고 하면, 제일 처음 자리의 숫자는 뒤의 n-1개의 숫자와 비교해야 할 겁니다. 그리고 그 뒤의 숫자는 n-2개의 숫자와 비교해야하니 전체 비교 횟수는 1부터 n까지의 시그마가 될 겁니다.

그러나 2개의 정렬된 n개와 m개의 두 부분집합으로 나누면, 최대 비교 횟수는 n+m-1이 됩니다. 즉, 합병의 시간 복잡도는 O(m+n)인 셈이죠.

<br/>

<br/>

## 2. 퀵 정렬

위의 합병 정렬은 데이터 모음을 정확하게 반쪽 냈지만 퀵 정렬은 조금 다릅니다. 퀵 정렬은 데이터를 쪼갠 후 *정복*하는 것이 아니라 데이터를 정복 후 쪼개기 때문이지요.

다음의 예시를 봅시다.

#### {30 80 90 70 50 20 60 10 40}

위와 같은 데이터 모음이 있었다고 할 때 합병 정렬을 적용했다면 절반의 위치인 50 앞에서 데이터는 반으로 갈라졌을 겁니다. 그러나 퀵 정렬을 적용한다면 50에서 데이터가 갈라지는 게 아니라, 50은 데이터의 기준점이 됩니다.

그리고 50보다 작은 숫자들은 왼쪽에, 큰 숫자들은 오른쪽에 정렬하여 그 후에 데이터를 분할하죠.

#### {10 20 30 40} {50} {60 70 80 90}

대략 다음처럼요. 이때 기준점이 되는 숫자를 *피봇*이라고 합니다. 이 피봇은 분할한 부분 문제에 포함되지 않습니다. 이 점을 유의하셔야 합니다.

```
QuickSort(A, left, right)
입력 : 배열  A[left]~A[right]
출력 : 정렬된 배열 A[left]~A[right]
if(left<right)
{
피봇을 A[left]~A[right] 중에서 선택하고, 피봇을 A[left]와 자리를 바꾼 후, 피봇과 배열의 각 원소를 비교하여 피봇보다 작은 숫자들은 A[left]~A[p-1]로 옮기고, 피봇보다 큰 숫자들은 A[p+1]~A[right]로 옮기며, 피봇은 A[p]에 놓는다.
QuickSort(A, left, p-1)
QuickSort(A, p+1, right)
}
```

퀵 정렬은 불안정 정렬에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 비교 정렬에 속합니다. 분할 정복 알고리즘의 하나로, 평균적으로 **매우 빠른 수행 속도**를 자랑합니다.

퀵 정렬에서 주의해야 할 점은 피봇의 선정 방법입니다.

만약, **피봇이 계속해서 가장 작은 수부터 선택된다면** 퀵 정렬에서 나올 수 있는 가장 최악의 시간 복잡도가 도출될 것입니다. 사실 그러한 가정은 퀵 정렬 알고리즘의 존재 의의 자체를 무의미하게 만들죠.

#### {... ... ... ...}

#### {... ...} {... ...}

#### {...} {...} {...} {...}

다음 처럼 항상 절반씩 입력이 분할되었을 때 분할하는 계층의 층수는 2층입니다. 각 층에서는 각각의 원소가 각 부분의 피봇과 1회씩 비교됩니다. 그러므로 총 비교횟수는 O(n)×층수 = O(n)×log<sub>2</sub>n = O(nlog<sub>2</sub>n)입니다.

이는 숫차 정렬이나 다름 없는 최소값만을 피봇으로 선택한 경우의 시간 복잡도인 O(n<sup>2</sup>)보다는 확연하게 짧죠.

그리고 피봇을 항상  랜덤하게 선택한다고 가정해도, 시간복잡도는 최선의 경우인 O(nlog<sub>2</sub>n)과 같습니다. 그러므로 피봇의 선택 방법은 다음의 두가지를 채택할 수 있습니다.

1. 랜덤하게 선정하는 방법

2. 3 숫자의 중앙값으로 선정하는 방법 : (가장 왼쪽 숫자, 중간 숫자, 가장 오른쪽 숫자 중에서 중앙 값으로 피봇을 정한다.)

   {**31** 17 42 9 **1** 23 18 11 **26**}가 있으면, **31 1 26** 중 중앙 값인 **26**을 피봇으로 선정한다.

<br/>

<br/>

## 선택 문제

선택 문제는 n개의 숫자들 중에서 k번째로 작은 숫자를 찾는 문제입니다. 

1. 최소 숫자를 k번 찾는다. 단, 최소 숫자를 찾은 뒤에는 입력해서 그 숫자를 제거한다.
2. 숫자들을 오름차순으로 정렬한 후, k번째 숫자를 찾는다.

위의 두가지는 k번째로 작은 숫자를 찾는 방법입니다. 그러나 이러한 알고리즘들은 각각 최악의 경우 O(kn)과 O(nlogn)의 수행 시간이 걸립니다. 선택 문제는 이보다 효율적인 해결을 위한 알고리즘입니다.

퀵 정렬과 어느정도 공통점이 있습니다. 우선 *피봇*을 선정하여 그걸 기준으로 좌우로 숫자를 나누죠. 그리고, 구하고자하는 k번째의 숫자가 왼쪽에 속하는지, 오른쪽에 속하는지를 가려내어 그 영역에서 원하는 해를 구하는 겁니다.

예를 들어 {Total Data}가 있으면 이를 피봇을 기준으로 왼쪽의 작은 {Small Data}와 오른쪽의 큰 {Large Data}로 나눌 수 있겠죠. 이때 구하고자 하는 k번째 작은 숫자가 {Small Data}에 속한다면 이 Small Data에서 알고리즘을 적용하여 해를 구하면 되고, 다른 Large Data는 아예 고려할 필요가 없는 겁니다. 때문에 문제를 선택한다해서 선택 문제죠.

<br/>

<br/>

## 분할 정복을 적용하는 데 있어서의 주의점

분할 정복이 부적절한 경우는 입력이 분할될 때마다 분할된 부분문제의 입력 크기의 합이 분할되기 전의 입력 크기보다 매우 커지는 경우입니다.

예를 들어 n번째의 피보나치 수를 구하는데 F(n) = F(n-1)+F(n-2)로 정의되므로 재귀 호출을 사용하는 것이 자연스러워 보이나, 이 경우의 입력은 1개이지만, 사실상 n의 값 자체가 입력 크기입니다. 따라서 n이라는 숫자로 인해 2개의 부분문제인 F(n-1)과 F(n-2)가 만들어지고, 2개의 입력 크기의 합이 (n-1) + (n-2) = (2n-3)이 되어서 분할 후 입력 크기가 거의 2배로 늘어납니다.

그리고 주어진 문제를 분할 정복 알고리즘으로 해결하려고 할 때에 주의해야 하는 또 하나의 요소는 취합(정복) 과정입니다. 입력을 분할만 한다고해서 효율적인 알고리즘이 만들어지는 것은 아닙니다. 오히려 분할하지 않은 경우가 더 효율적일 수도 있죠.

<a onclick="this.nextSibling.style.display=(this.nextSibling.style.display=='none')?'block':'none';" href="javascript:void(0)">큰정수의 곱셈</a><div style="DISPLAY: none">2개의 n->bit 정수의 곱을 분할 정복으로 계산하는 O(n<sup>2</sup>) 알고리즘을 제시하고, 시간복잡도가 O(n<sup>2</sup>)임을 보이라.<br/>

2개의 n->bit 정수를 분할 정복으로 계산하기 위한 개선된 O(n<sup>log<sub>2</sub>3</sup>) 알고리즘을 제시하라.</div>



> 큰 정수의 곱셈
>
> 스트라센의 행렬 곱셈 알고리즘
>
> 결정적(deterministic) 선택 알고리즘
>
> 점의 ㅆ아 찾기 문제
>
> 공제선 문제